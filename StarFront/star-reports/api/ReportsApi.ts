/**
 * Star.Web.Api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ReportsApi {

    protected basePath = 'http://localhost:5000';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * 
     * @summary Получение html разметки отчета.
     * @param reportId Идентификатор отчета
     * @param onlyBody В ответе придет только тело отчета, не весь html document
     * @param parameters Строка с параметрами для генерации отчета (Наименование параметра:Выражение для вычисления параметра;).
     * @param entityId Сущность-контейнер, относительно которой строится отчет.
     */
    public reportsExportToHtml(reportId: string, onlyBody?: boolean, parameters?: string, entityId?: string, extraHttpRequestParams?: any): Observable<any> {
        return this.reportsExportToHtmlWithHttpInfo(reportId, onlyBody, parameters, entityId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Получение отчета в формате PDF.
     * @param reportId Идентификатор отчета
     * @param accessId Одноразовый идентификатор доступа.
     * @param parameters Строка с параметрами для генерации отчета (Наименование параметра:Выражение для вычисления параметра;).
     * @param entityId Сущность-контейнер, относительно которой строится отчет.
     */
    public reportsExportToPdf(reportId: string, accessId: string, parameters?: string, entityId?: string, extraHttpRequestParams?: any): Observable<any> {
        return this.reportsExportToPdfWithHttpInfo(reportId, accessId, parameters, entityId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Получение отчета в формате XLS.
     * @param reportId Идентификатор отчета
     * @param accessId Одноразовый идентификатор доступа.
     * @param parameters Строка с параметрами для генерации отчета (Наименование параметра:Выражение для вычисления параметра;).
     * @param entityId Сущность-контейнер, относительно которой строится отчет.
     */
    public reportsExportToXls(reportId: string, accessId: string, parameters?: string, entityId?: string, extraHttpRequestParams?: any): Observable<any> {
        return this.reportsExportToXlsWithHttpInfo(reportId, accessId, parameters, entityId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Генерация и сохранение отчета.
     * @param reportTemplateId Идентификатор шаблона отчета.
     */
    public reportsGenerateReport(reportTemplateId: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.reportsGenerateReportWithHttpInfo(reportTemplateId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Получение шаблона отчета по идентификатору.
     * @param reportTemplateIdStr Идентификатор шаблона отчета.
     */
    public reportsGet(reportTemplateIdStr: string, extraHttpRequestParams?: any): Observable<models.ReportDto> {
        return this.reportsGetWithHttpInfo(reportTemplateIdStr, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Короткоживущий одноразовый идентификатор доступа для скачивания сгенерированного файла.
     * @param reportId Идентификатор шаблона отчета, экспорт которого был запущен.
     */
    public reportsGetAccessId(reportId: string, extraHttpRequestParams?: any): Observable<string> {
        return this.reportsGetAccessIdWithHttpInfo(reportId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Получение сформированных отчетов по заданному шаблону.
     * @param reportTemplateIdStr Идентификатор шаблона отчета.
     * @param skip Сколько пропустить записей.
     * @param top Размер страницы (сколько взять записей).
     * @param sort Сортировка
     * @param filter Фильтрация
     */
    public reportsGet_1(reportTemplateIdStr: string, skip?: number, top?: number, sort?: string, filter?: string, extraHttpRequestParams?: any): Observable<models.PageResultReportDocumentDto> {
        return this.reportsGet_1WithHttpInfo(reportTemplateIdStr, skip, top, sort, filter, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Получение html разметки отчета.
     * 
     * @param reportId Идентификатор отчета
     * @param onlyBody В ответе придет только тело отчета, не весь html document
     * @param parameters Строка с параметрами для генерации отчета (Наименование параметра:Выражение для вычисления параметра;).
     * @param entityId Сущность-контейнер, относительно которой строится отчет.
     */
    public reportsExportToHtmlWithHttpInfo(reportId: string, onlyBody?: boolean, parameters?: string, entityId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportId}/exportHtml'
                    .replace('${' + 'reportId' + '}', String(reportId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportId' is not null or undefined
        if (reportId === null || reportId === undefined) {
            throw new Error('Required parameter reportId was null or undefined when calling reportsExportToHtml.');
        }
        if (onlyBody !== undefined) {
            queryParameters.set('onlyBody', <any>onlyBody);
        }

        if (parameters !== undefined) {
            queryParameters.set('parameters', <any>parameters);
        }

        if (entityId !== undefined) {
            queryParameters.set('entityId', <any>entityId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Получение отчета в формате PDF.
     * 
     * @param reportId Идентификатор отчета
     * @param accessId Одноразовый идентификатор доступа.
     * @param parameters Строка с параметрами для генерации отчета (Наименование параметра:Выражение для вычисления параметра;).
     * @param entityId Сущность-контейнер, относительно которой строится отчет.
     */
    public reportsExportToPdfWithHttpInfo(reportId: string, accessId: string, parameters?: string, entityId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportId}/exportPdf/${accessId}'
                    .replace('${' + 'reportId' + '}', String(reportId))
                    .replace('${' + 'accessId' + '}', String(accessId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportId' is not null or undefined
        if (reportId === null || reportId === undefined) {
            throw new Error('Required parameter reportId was null or undefined when calling reportsExportToPdf.');
        }
        // verify required parameter 'accessId' is not null or undefined
        if (accessId === null || accessId === undefined) {
            throw new Error('Required parameter accessId was null or undefined when calling reportsExportToPdf.');
        }
        if (parameters !== undefined) {
            queryParameters.set('parameters', <any>parameters);
        }

        if (entityId !== undefined) {
            queryParameters.set('entityId', <any>entityId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'text/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Получение отчета в формате XLS.
     * 
     * @param reportId Идентификатор отчета
     * @param accessId Одноразовый идентификатор доступа.
     * @param parameters Строка с параметрами для генерации отчета (Наименование параметра:Выражение для вычисления параметра;).
     * @param entityId Сущность-контейнер, относительно которой строится отчет.
     */
    public reportsExportToXlsWithHttpInfo(reportId: string, accessId: string, parameters?: string, entityId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportId}/exportXls/${accessId}'
                    .replace('${' + 'reportId' + '}', String(reportId))
                    .replace('${' + 'accessId' + '}', String(accessId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportId' is not null or undefined
        if (reportId === null || reportId === undefined) {
            throw new Error('Required parameter reportId was null or undefined when calling reportsExportToXls.');
        }
        // verify required parameter 'accessId' is not null or undefined
        if (accessId === null || accessId === undefined) {
            throw new Error('Required parameter accessId was null or undefined when calling reportsExportToXls.');
        }
        if (parameters !== undefined) {
            queryParameters.set('parameters', <any>parameters);
        }

        if (entityId !== undefined) {
            queryParameters.set('entityId', <any>entityId);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'text/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Генерация и сохранение отчета.
     * 
     * @param reportTemplateId Идентификатор шаблона отчета.
     */
    public reportsGenerateReportWithHttpInfo(reportTemplateId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportTemplateId}/generate'
                    .replace('${' + 'reportTemplateId' + '}', String(reportTemplateId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportTemplateId' is not null or undefined
        if (reportTemplateId === null || reportTemplateId === undefined) {
            throw new Error('Required parameter reportTemplateId was null or undefined when calling reportsGenerateReport.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Получение шаблона отчета по идентификатору.
     * 
     * @param reportTemplateIdStr Идентификатор шаблона отчета.
     */
    public reportsGetWithHttpInfo(reportTemplateIdStr: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportTemplateIdStr}'
                    .replace('${' + 'reportTemplateIdStr' + '}', String(reportTemplateIdStr));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportTemplateIdStr' is not null or undefined
        if (reportTemplateIdStr === null || reportTemplateIdStr === undefined) {
            throw new Error('Required parameter reportTemplateIdStr was null or undefined when calling reportsGet.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Короткоживущий одноразовый идентификатор доступа для скачивания сгенерированного файла.
     * 
     * @param reportId Идентификатор шаблона отчета, экспорт которого был запущен.
     */
    public reportsGetAccessIdWithHttpInfo(reportId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportId}/access'
                    .replace('${' + 'reportId' + '}', String(reportId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportId' is not null or undefined
        if (reportId === null || reportId === undefined) {
            throw new Error('Required parameter reportId was null or undefined when calling reportsGetAccessId.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Получение сформированных отчетов по заданному шаблону.
     * 
     * @param reportTemplateIdStr Идентификатор шаблона отчета.
     * @param skip Сколько пропустить записей.
     * @param top Размер страницы (сколько взять записей).
     * @param sort Сортировка
     * @param filter Фильтрация
     */
    public reportsGet_1WithHttpInfo(reportTemplateIdStr: string, skip?: number, top?: number, sort?: string, filter?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/reports/${reportTemplateIdStr}/documents'
                    .replace('${' + 'reportTemplateIdStr' + '}', String(reportTemplateIdStr));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'reportTemplateIdStr' is not null or undefined
        if (reportTemplateIdStr === null || reportTemplateIdStr === undefined) {
            throw new Error('Required parameter reportTemplateIdStr was null or undefined when calling reportsGet_1.');
        }
        if (skip !== undefined) {
            queryParameters.set('skip', <any>skip);
        }

        if (top !== undefined) {
            queryParameters.set('top', <any>top);
        }

        if (sort !== undefined) {
            queryParameters.set('sort', <any>sort);
        }

        if (filter !== undefined) {
            queryParameters.set('filter', <any>filter);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json',
            'text/json'
        ];

        // authentication (oauth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
